import datetime
import xml.etree.ElementTree as ET
from xml.dom import minidom

class WeaselTree():
    """Tools for creating and handling ElementTrees based 
    Dicom Data and displayed in the Weasel TreeView.
    """ 

    def element_tree(self, msg="Creating element tree"):
        """
        Converts a Weasel DataFrame into an Element Tree.
        """   
        self.message(msg=msg)

        project_et = ET.Element('DICOM')
        comment = ET.Comment('WARNING: PLEASE, DO NOT MODIFY THIS FILE \n This .xml file is automatically generated by a script that reads folders containing DICOM files. \n Any changes can affect the software\'s functionality, so do them at your own risk')
        project_et.append(comment)

        self.project.sort_values(
            ['PatientID', 'StudyInstanceUID', 'SeriesNumber', 'InstanceNumber'], 
            inplace = True)

        for subject in self.project.PatientID.unique():
            subject = self.project[self.project.PatientID == subject]
            labels = self.data_labels(subject.iloc[0])     
            subject_element = ET.SubElement(project_et, 'subject')
            subject_element.set('id', labels[0])
            subject_element.set('expanded', 'True')  #added by SS 12.03.21
            subject_element.set('checked', 'False')  #added by SS 16.03.21
            for study in subject.StudyInstanceUID.unique():
                study = subject[subject.StudyInstanceUID == study]
                labels = self.data_labels(study.iloc[0])
                study_element = ET.SubElement(subject_element, 'study')
                study_element.set('id', labels[1])
                study_element.set('expanded', 'False') #added by SS 12.03.21
                study_element.set('checked', 'False')  #added by SS 16.03.21
                for series in study.SeriesInstanceUID.unique():
                    series = study[study.SeriesInstanceUID == series]
                    labels = self.data_labels(series.iloc[0])
                    series_element = ET.SubElement(study_element, 'series')
                    series_element.set('id', labels[2])
                    series_element.set('expanded', 'False') #added by SS 12.03.21
                    series_element.set('checked', 'False')  #added by SS 16.03.21
                    for filepath, image in series.iterrows():
                        labels = self.data_labels(image)
                        image_element = ET.SubElement(series_element, 'image')
                        image_element.set('checked', 'False')  #added by SS 16.03.21
                        ET.SubElement(image_element, 'label').text = labels[3]
                        ET.SubElement(image_element, 'name').text = filepath
                        ET.SubElement(image_element, 'time').text = labels[4]
                        ET.SubElement(image_element, 'date').text = labels[5]

        self.close_message()
        return project_et


    def data_labels(self, image):
        """Returns a set of human readable labels for a row in a DataFrame or a pyDicom Dataset.
        input: 
            image: row in a DataFrame or pyDicom DataSet
        output: 
            tuple of strings
        """ 
        subject_label = str(image.PatientName)
        subject_label += ' [' + str(image.PatientID) + ' ]'
        study_label = str(image.StudyDescription) + "_"
        study_label += str(image.StudyDate) + "_"
        study_label += str(image.StudyTime).split(".")[0]
        series_label = str(image.SeriesNumber) + "_"
        series_label += str(image.SeriesDescription)
        image_label = str(image.InstanceNumber).zfill(6)

        AcquisitionTime = str(image.AcquisitionTime)
        AcquisitionDate = str(image.AcquisitionDate)
        SeriesTime = str(image.SeriesTime)
        SeriesDate = str(image.SeriesDate)
        if not AcquisitionTime == 'Unknown':
            try:
                time_label = datetime.datetime.strptime(AcquisitionTime, '%H%M%S').strftime('%H:%M')
            except:
                time_label = datetime.datetime.strptime(AcquisitionTime, '%H%M%S.%f').strftime('%H:%M')
            date_label = datetime.datetime.strptime(AcquisitionDate, '%Y%m%d').strftime('%d/%m/%Y')
        elif not SeriesTime == 'Unknown': # It means it's Enhanced MRI
            try:
                time_label = datetime.datetime.strptime(SeriesTime, '%H%M%S').strftime('%H:%M')
            except:
                time_label = datetime.datetime.strptime(SeriesTime, '%H%M%S.%f').strftime('%H:%M')
            date_label = datetime.datetime.strptime(SeriesDate, '%Y%m%d').strftime('%d/%m/%Y')
        else:
            time_label = datetime.datetime.strptime('000000', '%H%M%S').strftime('%H:%M')
            date_label = datetime.datetime.strptime('20000101', '%Y%m%d').strftime('%d/%m/%Y')

        return subject_label, study_label, series_label, image_label, date_label, time_label

    def xml_string(self, project):
        """Turns an ElementTree into an xml string
        """ 
        xmlstr = ET.tostring(project, encoding='utf-8')
        xmlstr = minidom.parseString(xmlstr).toprettyxml(encoding="utf-8", indent="  ")
        return xmlstr

    def write_xml(self):
        """
        Saves an ElementTree as an XML file
        """
        self.message(msg="Writing XML file")
        tree = self.element_tree() 
        xmlstr = self.xml_string(tree)
        xml = self.xml()
        with open(xml, "wb") as f:
            f.write(xmlstr) 
        self.close_message() 

    def read_xml(self):
        """
        Reads an ElementTree from a CSV file
        """ 
        self.message(msg="Reading XML file")
        xml = self.xml()
        tree = ET.parse(xml)
        self.close_message()
        return tree

