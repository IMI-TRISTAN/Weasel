import numpy as np
from scipy.optimize import curve_fit
import concurrent.futures
import copy
from Developer.SciPackages.imagingTools import unWrapPhase, convertToPiRange

class ukrinMaps():
    """Package containing algorithms that calculate parameter maps 
    of the MRI scans acquired during the UKRIN-MAPS project.
    
    Attributes
    ----------
    See parameters of __init__ class

    """



    def __init__(self, pixelArray):
        """Initialise a UKRIN-MAPS class instance.
        
        Parameters
        ----------
        pixelArray : np.ndarray of N-dimensions
        """

        self.pixelArray = pixelArray

    # Consider splitting these methods into SubClasses at some point - Inheritance
    # Could create a Diffusion Toolbox where BValues are an atribute. Or Fitting, where Inversion Time and Echo Time are attributes.
    # https://www.youtube.com/watch?v=RSl87lqOXDE


    def B0Map(self, echoList):
    # See the following links regarding the unwrapping approach
    # https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/FUGUE/Guide
    # https://scikit-image.org/docs/dev/auto_examples/filters/plot_phase_unwrap.html
    # https://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.exp.html
        try:
            radiansArray = convertToPiRange(self.pixelArray) # Convert to [-pi, pi] if not in that range
            if len(echoList) > 1: # Is the given array already a Difference Phase or not?
                # Unwrap each phase image
                phase0 = unWrapPhase(np.squeeze(radiansArray[0, ...]))
                phase1 = unWrapPhase(np.squeeze(radiansArray[1, ...]))
                phaseDiff = phase1 - phase0
                deltaTE = np.absolute(echoList[1] - echoList[0]) * 0.001 # Conversion from ms to s
                del phase0, phase1
            else:
                # Unwrap difference phase image
                phaseDiff = unWrapPhase(radiansArray)
                try:
                    deltaTE = echoList[0] * 0.001
                except: # If echo is 0 or empty
                    deltaTE = 0.001
            derivedImage = phaseDiff / (2 * np.pi * deltaTE)
            # For B0Map from T2*, results are better if the unWrap occurs at phase diff.
            del phaseDiff, deltaTE
            return derivedImage
        except Exception as e:
            print('Error in function ukrinAlgorithms.B0Map: ' + str(e))


    def T2StarNottingham(self, echoList):
        """
        Generates a T2* map from a series of volumes collected with different echo times.

        Parameters
        ----------
        pixelArray : 4D/3D array
            A 4D/3D array containing the signal from each voxel at each echo time i.e. the dimensions of the array
            are [x, y, z, TE].
        echoList : Array
            An array of the echo times used for the last dimension of the raw data.

        Returns
        -------
        t2star : 3D array
            An array containing the T2* map generated by the function with T2* measured in milliseconds.
        r2star : 3D array
            An array containing the R2* map generated by the function with R2* measured in milliseconds.
        m0 : 3D array
            An array containing the M0 map generated by the function.
        """
        try:
            self.pixelArray[self.pixelArray == 0] = 1E-10
            # If raw data is 2D (3D inc echo times) then add a dimension so it can be processed in the same way as 3D data
            if len(self.pixelArray.shape) == 3:
                self.pixelArray = np.expand_dims(self.pixelArray, 2)

            t2star = np.zeros(self.pixelArray.shape[0:3])
            r2star = np.zeros(self.pixelArray.shape[0:3])
            m0 = np.zeros(self.pixelArray.shape[0:3])
            with np.errstate(invalid='ignore', over='ignore'):
                for s in range(self.pixelArray.shape[2]):
                    for x in range(np.shape(self.pixelArray)[0]):
                        for y in range(np.shape(self.pixelArray)[1]):
                            noise = 0.0
                            sd = 0.0
                            s_w = 0.0
                            s_wx = 0.0
                            s_wx2 = 0.0
                            s_wy = 0.0
                            s_wxy = 0.0
                            for d in range(self.pixelArray.shape[3]):
                                noise = noise + self.pixelArray[x, y, s, d]
                                sd = sd + self.pixelArray[x, y, s, d] * \
                                    self.pixelArray[x, y, s, d]
                            noise = noise / self.pixelArray.shape[3]
                            sd = sd / self.pixelArray.shape[3] - noise ** 2
                            sd = sd ** 2
                            sd = np.sqrt(sd)
                            for d in range(self.pixelArray.shape[3]):
                                te_tmp = echoList[d]  # It's in seconds and not ms
                                if self.pixelArray[x, y, s, d] > sd:
                                    sigma = np.log(
                                        self.pixelArray[x, y, s, d] / (self.pixelArray[x, y, s, d] - sd))
                                    sig = self.pixelArray[x, y, s, d]
                                    weight = 1 / (sigma ** 2)
                                else:
                                    sigma = np.log(self.pixelArray[x, y, s, d] / 0.0001)
                                    sig = np.log(self.pixelArray[x, y, s, d])
                                    weight = 1 / (sigma ** 2)
                                weight = 1 / (sigma ** 2)
                                s_w = s_w + weight
                                s_wx = s_wx + weight * te_tmp
                                s_wx2 = s_wx2 + weight * te_tmp ** 2
                                s_wy = s_wy + weight * sig
                                s_wxy = s_wxy + weight * te_tmp * sig
                            delta = (s_w * s_wx2) - (s_wx ** 2)
                            if (delta == 0.0) or (np.isinf(delta)) or (np.isnan(delta)):
                                t2star[x, y, s] = 0
                                r2star[x, y, s] = 0
                                m0[x, y, s] = 0
                            else:
                                a = (1 / delta) * (s_wx2 * s_wy - s_wx * s_wxy)
                                b = (1 / delta) * (s_w * s_wxy - s_wx * s_wy)
                                t2stars_temp = np.real(-1 / b)
                                r2stars_temp = np.real(-b)
                                m0_temp = np.real(np.exp(a))
                                if (t2stars_temp < 0) or (t2stars_temp > 500):
                                    t2star[x, y, s] = 0
                                    r2star[x, y, s] = 0
                                    m0[x, y, s] = 0
                                else:
                                    t2star[x, y, s] = t2stars_temp
                                    r2star[x, y, s] = r2stars_temp
                                    m0[x, y, s] = m0_temp
            del t2stars_temp, r2stars_temp, m0_temp, delta
            return t2star, r2star, m0
        except Exception as e:
            print('Error in function ukrinAlgorithms.T2StarNottingham: ' + str(e))


    def T2Star(self, echoList):
        try:
            self.pixelArray[self.pixelArray == 0] = 1E-10
            # If raw data is 2D (3D inc echo times) then add a dimension so it can be processed in the same way as 3D data
            if len(self.pixelArray.shape) == 3:
                self.pixelArray = np.expand_dims(self.pixelArray, 2)
            numberEchoes = len(echoList)
            # for [x,y,z,TE], do self.pixelArray[..., 0]
            matrixOnes = np.ones(np.shape(np.squeeze(self.pixelArray[0, ...])))
            with np.errstate(invalid='ignore', over='ignore'):
                # for [x,y,z,TE], do axis=3
                noise = np.sum(self.pixelArray, axis=0) / (numberEchoes * matrixOnes)
                sd = np.absolute(np.sum(np.square(self.pixelArray), axis=0) / (numberEchoes * matrixOnes) - np.square(noise))
                s_w = s_wx = s_wx2 = s_wy = s_wxy = np.zeros(np.shape(matrixOnes))
                for echo in range(numberEchoes):
                    te = echoList[echo] * matrixOnes #It's in seconds and not ms
                    sigma = sig = np.zeros(np.shape(matrixOnes))
                    matrixIterator = np.nditer(sd, flags=['multi_index'])
                    while not matrixIterator.finished:
                        # for [x,y,z,TE], swap [echo][index] to [index][echo]
                        index = matrixIterator.multi_index
                        if self.pixelArray[echo][index] > sd[index]:
                            sigma[index] = np.log(self.pixelArray[echo][index] / (self.pixelArray[echo][index] - sd[index]))
                            sig[index] = self.pixelArray[echo][index]
                        else:
                            sigma[index] = np.log(self.pixelArray[echo][index] / 0.0001)
                            sig[index] = np.log(self.pixelArray[echo][index])
                        matrixIterator.iternext()
                    weight = matrixOnes / np.square(sigma)
                    s_w = s_w + weight
                    s_wx = s_wx + (weight * te)
                    s_wx2 = s_wx2 + weight * np.square(te)
                    s_wy = s_wy + weight * sig
                    s_wxy = s_wxy + weight * te * sig
                delta = (s_w * s_wx2) - (np.square(s_wx))
                b = (matrixOnes / delta) * (s_w * s_wxy - s_wx * s_wy)
                t2Star = np.real(-matrixOnes / b)
                conditions = (np.isinf(t2Star)) | (np.isnan(t2Star)) | (t2Star < 0.0) | (t2Star > 500.0)
                t2Star = np.where(conditions, 0.0, t2Star)
            return t2Star
        except Exception as e:
            print('Error in function ukrinAlgorithms.T2Star: ' + str(e))


    def R2Star(self, echoList):
        try:
            return np.ones(np.shape(self.pixelArray))/self.T2Star(echoList)
        except Exception as e:
            print('Error in function ukrinAlgorithms.R2Star: ' + str(e))


    def T1MapMolli(self, inversionList):
        try:
            import matlab.engine
            eng = matlab.engine.start_matlab()
            inputArray = matlab.double(np.array(self.pixelArray).tolist())
            ti = matlab.double(np.array(inversionList).tolist())
            ti.reshape((len(inversionList), 1))
            mapMatlab = eng.T1Fitting(inputArray, ti, nargout=1)
            t1Map = np.transpose(np.array(mapMatlab)) # Convert to Python array and transpose because the Matlab script does it.
            t1Map = np.nan_to_num(t1Map) # There migh be Infs and NaNs
            # Set boundaries
            t1Map[t1Map>2500] = 2500
            t1Map[t1Map<10] = 0
            eng.quit()
            return t1Map
        except Exception as e:
            print('Error in function ukrinAlgorithms.T1MapMolli: ' + str(e))


    def T1MapDraft(self, inversionList):
        try:
            yData = copy.deepcopy(self.pixelArray)
            x0 = [np.amax(self.pixelArray), np.amax(self.pixelArray)-np.amin(self.pixelArray), 50.0]
            lb = [0, -np.inf, 0]
            ub = [np.inf, np.inf, 3000.0]

            # Null point selection - after this step everything below lowest value will be negative
            nullPointMatrix = np.argmin(self.pixelArray, axis=2) # Get the TI indices where value is minimum
            for ix, iy in np.ndindex(nullPointMatrix.shape):
                tiIndex = nullPointMatrix[ix,iy]
                if tiIndex > 0:
                    yData[ix,iy,0:tiIndex] = -self.pixelArray[ix,iy,0:tiIndex]

            T1Apparent = []
            for ix, iy in np.ndindex(nullPointMatrix.shape):
                T1pixel, _ = curve_fit(T1Fitting, inversionList, yData[ix,iy,:], p0=x0, bounds=(lb, ub), maxfev=2000)
                T1Apparent.append(T1pixel)
            T1Apparent = np.array(T1Apparent)

            T1Estimated = T1Apparent[:,2] * ((T1Apparent[:,1] / T1Apparent[:,0]) - np.ones(np.shape(T1Apparent[:,0]))) #T1_estimated((B/A)-1)
            T1Map = np.transpose(np.nan_to_num(np.reshape(T1Estimated, np.shape(nullPointMatrix))))
            T1Map[T1Map>3000] = 3000
            T1Map[T1Map<10] = 0
            return T1Map
        except Exception as e:
            print('Error in function ukrinAlgorithms.T1MapDraft: ' + str(e))
    

    def T1MapMain(self, inversionList):
        try:
            # Initial values / Conditions
            #x0 = [np.amax(self.pixelArray), np.amax(self.pixelArray)-np.amin(self.pixelArray), 50.0]
            #lb = [0, -np.inf, 0]
            #ub = [np.inf, np.inf, 5000.0]
            x0 = [1000, 30000, 2]
            lb = [0, 0, 1]
            ub = [4000, 1000000, 2]
            T1Fitting = lambda ti, a, b, t1: a - b * np.exp(-ti / t1)
            T1Apparent = []
            if len(self.pixelArray.shape) == 3:
                # Null point selection - after this step everything below lowest value will be negative
                nullPointMatrix = np.argmin(self.pixelArray, axis=2) # Get the TI indices where value is minimum
                for ix, iy in np.ndindex(nullPointMatrix.shape):
                    yData = []
                    tiIndex = nullPointMatrix[ix,iy]
                    if tiIndex > 0:
                        yData[0:tiIndex] = -self.pixelArray[ix,iy,0:tiIndex]
                        yData[tiIndex:] = self.pixelArray[ix,iy,tiIndex:]
                    else:
                        yData = self.pixelArray[ix,iy,:]
                    # Perform the Levenberg-Marquardt least squares fitting
                    try:
                        T1pixel, _ = curve_fit(np.vectorize(T1Fitting), np.array(inversionList), np.array(yData), p0=x0, bounds=(lb, ub), maxfev=2000)
                    except: # If optimization fails, then perform fitting like assuming that the pizel value is zero
                        T1pixel, _ = curve_fit(np.vectorize(T1Fitting), np.array(inversionList), np.zeros(np.shape(yData)), p0=x0, bounds=(lb, ub), maxfev=2000)
                    T1Apparent.append(T1pixel)
            elif len(self.pixelArray.shape) == 4:
                # Null point selection - after this step everything below lowest value will be negative
                nullPointMatrix = np.argmin(self.pixelArray, axis=3) # Get the TI indices where value is minimum
                for ix, iy, iz in np.ndindex(nullPointMatrix.shape):
                    yData = []
                    tiIndex = nullPointMatrix[ix,iy,iz]
                    if tiIndex > 0:
                        yData[0:tiIndex] = -self.pixelArray[ix,iy,iz,0:tiIndex]
                        yData[tiIndex:] = self.pixelArray[ix,iy,iz,tiIndex:]
                    else:
                        yData = self.pixelArray[ix,iy,iz,:]
                    # Perform the Levenberg-Marquardt least squares fitting
                    try:
                        T1pixel, _ = curve_fit(np.vectorize(T1Fitting), np.array(inversionList), np.array(yData), p0=x0, bounds=(lb, ub), maxfev=2000)
                    except: # If optimization fails, then perform fitting like assuming that the pizel value is zero
                        T1pixel, _ = curve_fit(np.vectorize(T1Fitting), np.array(inversionList), np.zeros(np.shape(yData)), p0=x0, bounds=(lb, ub), maxfev=2000)
                    T1Apparent.append(T1pixel)
            
            T1Apparent = np.array(T1Apparent)
            T1Estimated = T1Apparent[:,2] * ((T1Apparent[:,1] / T1Apparent[:,0]) - np.ones(np.shape(T1Apparent[:,0]))) #T1_estimated((B/A)-1)
            T1Map = np.transpose(np.nan_to_num(np.reshape(T1Estimated, np.shape(nullPointMatrix))))
            T1Map[T1Map>5000] = 5000
            T1Map[T1Map<50] = 0
            return T1Map
        except Exception as e:
            print('Error in function ukrinAlgorithms.T1Map: ' + str(e))
    

    def T1Map(self, inversionList):
        try:
            # Initial values / Conditions
            #x0 = [np.amax(self.pixelArray), np.amax(self.pixelArray)-np.amin(self.pixelArray), 50.0]
            #lb = [0, -np.inf, 0]
            #ub = [np.inf, np.inf, 5000.0]
            x0 = [1000, 30000, 2]
            lb = [0, 0, 1]
            ub = [4000, 1000000, 2]
            dataToFit = np.zeros(np.shape(self.pixelArray))
            if len(self.pixelArray.shape) == 3:
                # Null point selection - after this step everything below lowest value will be negative
                nullPointMatrix = np.argmin(self.pixelArray, axis=2) # Get the TI indices where value is minimum
                for ix, iy in np.ndindex(nullPointMatrix.shape):
                    yData = []
                    tiIndex = nullPointMatrix[ix,iy]
                    if tiIndex > 0:
                        yData[0:tiIndex] = -self.pixelArray[ix,iy,0:tiIndex]
                        yData[tiIndex:] = self.pixelArray[ix,iy,tiIndex:]
                    else:
                        yData = self.pixelArray[ix,iy,:]
                    dataToFit[ix,iy,:] = yData
                # Perform the Levenberg-Marquardt least squares fitting
                with concurrent.futures.ProcessPoolExecutor() as executor:
                    results = [[executor.submit(FittingScript, inversionList, dataToFit[ix,iy,:], x0, lb, ub), (ix, iy)] for ix, iy in np.ndindex(nullPointMatrix.shape)]
                
            elif len(self.pixelArray.shape) == 4:
                # Null point selection - after this step everything below lowest value will be negative
                nullPointMatrix = np.argmin(self.pixelArray, axis=3) # Get the TI indices where value is minimum
                for ix, iy, iz in np.ndindex(nullPointMatrix.shape):
                    yData = []
                    tiIndex = nullPointMatrix[ix,iy,iz]
                    if tiIndex > 0:
                        yData[0:tiIndex] = -self.pixelArray[ix,iy,iz,0:tiIndex]
                        yData[tiIndex:] = self.pixelArray[ix,iy,iz,tiIndex:]
                    else:
                        yData = self.pixelArray[ix,iy,iz,:]
                    dataToFit[ix,iy,iz,:] = yData
                # Perform the Levenberg-Marquardt least squares fitting
                with concurrent.futures.ProcessPoolExecutor() as executor:
                    results = [[executor.submit(FittingScript, inversionList, dataToFit[ix,iy,iz,:], x0, lb, ub), (ix, iy, iz)] for ix, iy, iz in np.ndindex(nullPointMatrix.shape)]

            indexes = []
            fittedData = []
            T1Map = np.zeros(np.shape(nullPointMatrix))
            for individual_result in results:
                fittedData.append(individual_result[0].result())
                indexes.append(individual_result[1])
            T1Apparent = np.array(fittedData)
            T1Estimated = T1Apparent[:,2] * ((T1Apparent[:,1] / T1Apparent[:,0]) - np.ones(np.shape(T1Apparent[:,0]))) #T1_estimated((B/A)-1)
            for index, location in enumerate(indexes): T1Map[location] = T1Estimated[index]
            T1Map = np.nan_to_num(T1Map)
            T1Map[T1Map>5000] = 0
            T1Map[T1Map<50] = 0
            return T1Map
        except Exception as e:
            print('Error in function ukrinAlgorithms.T1Map: ' + str(e))

T1Fitting = np.vectorize(lambda ti, a, b, t1: a - b * np.exp(-ti / t1))
def FittingScript(inversionList, data, p0, lb, ub):
    try:
        try:
            T1pixel, _ = curve_fit(T1Fitting, np.array(inversionList), np.array(data), p0=p0, bounds=(lb, ub))
        except: # If optimization fails, then perform fitting like assuming that the pixel value is zero
            T1pixel, _ = curve_fit(T1Fitting, np.array(inversionList), np.zeros(np.shape(data)), p0=p0, bounds=(lb, ub))
        return T1pixel
    except Exception as e:
        print('Error in function ukrinAlgorithms.FittingScript: ' + str(e))

#def T1Fitting(ti, a, b, t1):
    #return a - b * np.exp(-ti / t1)
